import React, {cloneElement} from 'react';
import rehypeReact from 'rehype-react';

// note - these typographic elements are taken directly from baseui.
// we can consider customizing them by first importing in styled/index, then
// giving them special parameters

import {
  A,
  GatsbyA,
  CodeBlock,
  H1,
  H2,
  H3,
  H4,
  H5,
  H6,
  InlineCode,
  P,
  List,
  ListItem,
  Pre,
  BlockQuote,
  Table,
  TableHeaderCell,
  TableBodyCell
} from '../styled/typography';

import {parseLinks} from '../../utils/links-utils.js';

const CustomLinkWrapper = (path, relativeLinks) => {
  const CustomLink = ({href, ...props}) => {
    const updatedLink = parseLinks(href, path, relativeLinks);
    return updatedLink ? <GatsbyA to={updatedLink} {...props} /> : <A href={href} {...props} />;
  };
  return CustomLink;
};

const CustomPre = props => {
  // the point of this component is to distinguish styling of inline <code /> elements
  // with code blocks (ie <pre><code>...</code></pre>).

  const {children, ...otherProps} = props;
  return (
    <Pre {...otherProps}>
      {React.Children.map(children, child => {
        // this means a child of this <pre> element is a <code> element, or <code> element styled
        // by Styletron
        if (
          child.type === 'code' ||
          child.type.displayName === 'Styled(code)'
        ) {
          return <CodeBlock {...child.props} />;
        }
        // else we just clone the element as is
        return React.cloneElement(child);
      })}
    </Pre>
  );
};

const API_REGEX = /^code-classlanguage-text(.*?)code/;
const CODE_REGEX = /code-classlanguage-text(.*?)code/g;

// Sanitize auto generated anchor ids
const CustomHeader = (ComponentType, id, props, anchors) => {
  if (API_REGEX.test(id)) {
    id = id.match(API_REGEX)[1];
  } else {
    id = id.replace(CODE_REGEX, ($0, $1) => $1);
  }
  // Make sure we don't have duplicate ids on this page
  if (anchors[id]) {
    let suffix = 1;
    while (anchors[`${id}-${suffix}`]) suffix++;
    id = `${id}-${suffix}`;
  }
  anchors[id] = true;

  const children = props.children.slice();
  const autolink = children[0];
  if (autolink.props && autolink.props.href) {
    children[0] = cloneElement(autolink, {href: `#${id}`})
  }
  return <ComponentType {...props} id={id}>{children}</ComponentType>;
}

export default props => {
  const {relativeLinks, path} = props;
  // note - we can add many other custom components.

  const anchors = {};
  const HeaderWrapper = ComponentType => {
    return ({id, ...props}) => CustomHeader(ComponentType, id, props, anchors);
  };

  // without rehypeReact, we'd just render the content of the markdown as generated by gatsby.
  // what this does is that instead we work on the Abstract Syntax Tree (htmlAST).
  // this allows us to replace certain elements by custom components. For instance, if we
  // detect an <h1> element, we will replace it with an H1 custom component. In that case
  // H1 is just a styled version of h1. However, with that process we can implement custom
  // logic. For instance we can rewrite the contents of the link on the fly (CustomLinkWrapper).
  // we can style differently code tags which are within or without a <pre> element. And we can
  // add many more such custom components as needed.
  const renderAst = new rehypeReact({
    createElement: React.createElement,
    components: {
      h1: H1,
      h2: HeaderWrapper(H2),
      h3: HeaderWrapper(H3),
      h4: HeaderWrapper(H4),
      h5: HeaderWrapper(H5),
      h6: HeaderWrapper(H6),
      p: P,
      ul: List,
      li: ListItem,
      pre: CustomPre,
      code: InlineCode,
      table: Table,
      th: TableHeaderCell,
      td: TableBodyCell,
      blockquote: BlockQuote,
      a: relativeLinks ? CustomLinkWrapper(path, relativeLinks) : A
    }
  }).Compiler;

  return renderAst(props.htmlAst);
}
