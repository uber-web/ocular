{"version":3,"sources":["../../../../src/gatsby-node/on-create-node/process-nodes-markdown.js"],"names":["path","require","_","log","COLOR","removeURLPathPrefix","parseToc","queue","entry","length","n","shift","chapters","forEach","c","push","entries","e","module","exports","processNewMarkdownNode","ocularOptions","docNodes","tocNode","node","actions","getNode","createNodeField","fileNode","parent","parsedFilePath","parse","relativePath","title","frontmatter","slug","kebabCase","name","dir","relPath","relative","ROOT_FOLDER","fileAbsolutePath","basename","dirname","tocNodePath","HOME_PATH","value","nodeToEdit","childMdx","fields","priority","color","YELLOW","addSiblingNodes","addSourceInstanceName","pluginOptions","loadNodeContent","createNodeId","reporter","sourceInstanceName","addMissingFrontmatter","rawBody","heading","match","tags","category","cover","type","cleanupMarkdownNode","processed","internal","mediaType","arguments"],"mappings":"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","sourcesContent":["// TODO: fix lint errors in this file\n/* eslint-disable */\nconst path = require('path');\n// const moment = require('moment');\n// TODO/ib - remove\nconst _ = require('lodash');\nconst {log, COLOR} = require('../../utils/log');\nconst {removeURLPathPrefix} = require('../../utils/links-utils');\n\nfunction parseToc(queue, entry) {\n  // this function returns a node in the TOC that has an entry corresponding to\n  // the path of the current markdown node\n  while (queue.length) {\n    const n = queue.shift();\n    if (n.entry === entry) {\n      return n;\n    }\n    (n.chapters || []).forEach((c) => queue.push(c));\n    (n.entries || []).forEach((e) => queue.push(e));\n  }\n  // entry not found\n  return null;\n}\n\n// Patches up new markdown nodes\n//\nmodule.exports.processNewMarkdownNode = function processNewMarkdownNode(\n  {node, actions, getNode},\n  ocularOptions,\n  docNodes,\n  tocNode\n) {\n  const {createNodeField} = actions;\n\n  const fileNode = getNode(node.parent);\n  const parsedFilePath = path.parse(fileNode.relativePath);\n  let title;\n  if (node.frontmatter) {\n    title = node.frontmatter.title;\n  }\n\n  let slug;\n  if (title) {\n    slug = `/${_.kebabCase(title)}`;\n  } else if (parsedFilePath.name !== 'index' && parsedFilePath.dir !== '') {\n    slug = `/${parsedFilePath.dir}/${parsedFilePath.name}/`;\n  } else if (parsedFilePath.dir === '') {\n    slug = `/${parsedFilePath.name}/`;\n  } else {\n    slug = `/${parsedFilePath.dir}/`;\n  }\n\n  // Update path\n  let relPath = path.relative(ocularOptions.ROOT_FOLDER, node.fileAbsolutePath);\n\n  let basename = path.basename(relPath, '.md');\n  basename = path.basename(basename, '.mdx');\n  const dirname = path.dirname(relPath);\n  relPath = basename === 'README' ? dirname : `${dirname}/${basename}`;\n\n  // Store the path before potentially modifying as we want to keep the HOME_PATH for ToC lookup\n  const tocNodePath = relPath;\n\n  // remove prefix from the path to set HOME_PATH as root url (index)\n  if (ocularOptions.HOME_PATH) {\n    relPath = removeURLPathPrefix(relPath, ocularOptions.HOME_PATH);\n  }\n\n  createNodeField({node, name: 'path', value: relPath});\n  createNodeField({node, name: 'slug', value: relPath});\n  node.frontmatter.path = relPath;\n  node.frontmatter.title = title || '';\n\n  if (tocNode) {\n    // this means toc node has been created. Any markdown file processed beyond this point wouldn't have its info\n    // in the toc.\n    // but we can inject it afterwards\n\n    // the regular toc node generation process adds the full content of each markdown node to the toc.\n    // we don't need as much. The app will only use the title and slug of the corresponding markdown\n    // node for each toc entry.\n\n    const nodeToEdit = parseToc([tocNode], tocNodePath);\n    if (nodeToEdit) {\n      nodeToEdit.childMdx = {\n        fields: {\n          slug: relPath\n        },\n        frontmatter: {\n          title: node.frontmatter.title\n        }\n      };\n    }\n    log.log({priority: 4, color: COLOR.YELLOW}, `putting ${relPath} back in the TOC`)();\n  }\n\n  // while toc node isn't created, we can add the docs nodes to docNodes, which is used to add data to the TOC\n  docNodes[relPath] = node;\n};\n\nmodule.exports.addSiblingNodes = function addSiblingNodes(createNodeField) {\n  // postNodes.sort(\n  //   ({ frontmatter: { date: date1 } }, { frontmatter: { date: date2 } }) => {\n  //     const dateA = moment(date1, siteConfig.dateFromFormat);\n  //     const dateB = moment(date2, siteConfig.dateFromFormat);\n  //     if (dateA.isBefore(dateB)) return 1;\n  //     if (dateB.isBefore(dateA)) return -1;\n  //     return 0;\n  //   }\n  // );\n  // for (let i = 0; i < postNodes.length; i += 1) {\n  //   const nextID = i + 1 < postNodes.length ? i + 1 : 0;\n  //   const prevID = i - 1 > 0 ? i - 1 : postNodes.length - 1;\n  //   const currNode = postNodes[i];\n  //   const nextNode = postNodes[nextID];\n  //   const prevNode = postNodes[prevID];\n  //   createNodeField({\n  //     node: currNode,\n  //     name: 'nextTitle',\n  //     value: nextNode.frontmatter.title\n  //   });\n  //   createNodeField({\n  //     node: currNode,\n  //     name: 'nextSlug',\n  //     value: nextNode.fields.slug\n  //   });\n  //   createNodeField({\n  //     node: currNode,\n  //     name: 'prevTitle',\n  //     value: prevNode.frontmatter.title\n  //   });\n  //   createNodeField({\n  //     node: currNode,\n  //     name: 'prevSlug',\n  //     value: prevNode.fields.slug\n  //   });\n  // }\n};\n\n// Ensure sourceInstanceName (added by gatsby-source-filsystem config options)\n// is present on nodes generated by gatsby-transform-remark\nfunction addSourceInstanceName(\n  {node, getNode, loadNodeContent, actions, createNodeId, reporter},\n  pluginOptions\n) {\n  const {createNodeField} = actions;\n\n  const parent = getNode(node.parent);\n\n  const sourceInstanceName =\n    parent && parent.sourceInstanceName ? parent.sourceInstanceName : 'unknown';\n\n  // Add node field\n  createNodeField({\n    node,\n    name: 'sourceName',\n    value: sourceInstanceName\n  });\n\n  // console.error('adding', sourceInstanceName, node.fields.sourceInstanceName)\n\n  // if (!parent) {\n  //   // Node has already been processed.\n  //   console.error('Ocular markdown node has no parent', JSON.stringify(node.parent), JSON.stringify(node.sourceInstanceName), node.relativePath);\n  //   return;\n  // }\n\n  if (parent) {\n    addMissingFrontmatter(node, sourceInstanceName);\n  }\n}\n\nfunction addMissingFrontmatter(node, sourceInstanceName) {\n  // Populate frontmatter\n  if (node.frontmatter) {\n    if (node.rawBody) {\n      const heading = node.rawBody.match(/^#+ (.*)$/m);\n      node.frontmatter.title = heading ? heading[1] : '';\n      // console.warn(`Ocular processing doc article '${title}'`);\n    }\n    node.frontmatter.tags = ['default'];\n    node.frontmatter.category = 'docs';\n    node.frontmatter.cover = 'cover';\n    node.frontmatter.type = sourceInstanceName;\n  }\n}\n\nmodule.exports.cleanupMarkdownNode = function cleanupMarkdownNode(\n  {node, getNode, loadNodeContent, actions, createNodeId, reporter},\n  pluginOptions\n) {\n  let processed = false;\n\n  if (!processed) {\n    switch (node.internal.mediaType) {\n      case `text/markdown`:\n      case `text/x-markdown`:\n        addSourceInstanceName(...arguments);\n        processed = true;\n        break;\n\n      default:\n    }\n  }\n\n  // Secondary nodes created by remark\n  if (!processed) {\n    switch (node.internal.type) {\n      case 'MarkdownRemark':\n      case 'Markdown':\n      case 'Mdx':\n        addSourceInstanceName(...arguments);\n        processed = true;\n        break;\n\n      default:\n    }\n  }\n\n  // if (!processed) {\n  //   if (node.internal.mediaType ==- 'application/json') {\n  //   }\n  //   if (node.id === 'table-of-contents') {\n  //   }\n  //   console.warn('Ocular ignoring node',\n  //     node.absolutePath, node.internal.mediaType, node.internal.type, node.sourceInstanceName);\n  // }\n};\n\n/* eslint-enable */\n"],"file":"process-nodes-markdown.js"}